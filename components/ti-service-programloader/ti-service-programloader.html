<!--
    Copyright (c) 2019, 2021 Texas Instruments Incorporated
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

    *   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
    *   Neither the name of Texas Instruments Incorporated nor the names of
    its contributors may be used to endorse or promote products derived
    from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
    OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
    OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
    EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../ti-service-programloader/ti-service-programloader-dialog.html">
<link rel="import" href="../ti-core-assets/ti-core-assets.html">
<link rel="import" href="../ti-core-connection-manager/ti-core-connection-manager.html">
<link rel="import" href="../ti-core-backplane/ti-core-backplane.html">
<!--
`ti-service-programloader` enables downloading a binary file, erasing the target flash and burning the program into flash.

Example:

    <ti-service-programloader></ti-service-programloader>

See demo.html for a full working example of how to use this component.

@group Ti Elements
@element ti-service-programloader
@demo demo.html
@homepage ../ti-guicomposer-helpindex/demo.html
-->
<dom-module id='ti-service-programloader'  >
    <template>
        <style>
            :host {
                display: block;
                width: 175px;
                height: 175px;
            }
        </style>
        <ti-core-backplane id="backplane" hidden style="display:none"></ti-core-backplane>
    </template>
    <script>
        var gc = gc || {};
            (function() {
                var ServiceName = 'ti-service-programloader';
            var programLoaderServiceInstances = [];

            Polymer ({
                is: 'ti-service-programloader',
                /** @private */
                _self: undefined,
                /** @private */
                deleteSerialioUponDetach: false,
                /** @private */
                ds_loader: undefined,
                /** @private */
                ds: undefined,
                /** @private */
                core: undefined,
                /** @private */
                foundFlashMsg: false,
                /** @private */
                myTimeout: null,
                /** @private */
                MS_WAIT_FOR_FLASH_PROGRAMMING_COMPLETE: 75000,//was 45000
                /** @private */
                states: [  // http://lamehacks.net/blog/implementing-a-state-machine-in-javascript/

                    {
                        'name': 'disconnected',
                        'statusString': '',
                        'waitForUser': true,
                        'caption': 'Connect',
                        'skip': false,
                        'events': {
                            'gotoNextState': 'backplaneReady',
                            'backplane_ready': 'backplaneReady',
                            'backplane_disconnect': 'disconnected',
                            'backplane_disconnected': 'disconnected',
                            'showDownloadProgramBtn': 'showDownloadProgramBtn',
                            'backplane_downloadTICloudAgent': 'disconnected'
                        }
                    },

                    {
                        'name': 'backplaneReady',
                        'statusString': '',
                        'waitForUser': false,
                        'caption': 'Connected',
                        'skip': false,
                        'events': {
                            'gotoNextState': 'showDownloadProgramBtn',
                            'onTargetReady': 'showDownloadProgramBtn',
                            'showDownloadProgramBtn': 'showDownloadProgramBtn',
                            'backplane_disconnect': 'disconnected',
                            'backplane_disconnected': 'disconnected',
                            'backplane_downloadTICloudAgent': 'disconnected'

                        }
                    },
                    {
                        'name': 'waitForDeviceToBePluggedIn',
                        'statusString': "",
                        'caption': 'Disconnect',
                        'waitForUser': true,
                        'skip': false,
                        'events': {
                            'gotoNextState': 'disconnected',
                            'onDownloadProgramError': 'waitForDeviceToBePluggedIn',
                            'showDownloadProgramBtn': 'showDownloadProgramBtn',
                            'onUserSaysDevicePluggedIn': 'disconnected',
                            'backplane_disconnect': 'disconnected',
                            'backplane_disconnected': 'disconnected',
                            'backplane_downloadTICloudAgent': 'disconnected'
                        }
                    },
                    {
                        'name': 'showDownloadProgramBtn',
                        'caption': 'Download Program',
                        'statusString': "",
                        'waitForUser': true,
                        'skip': false,
                        'events': {
                            'gotoNextState': 'downloadProgram',
                            'downloadProgram': 'downloadProgram',
                            'onProgramDownloadBtnClicked': 'downloadProgram',
                            'onSkipProgramDownloadBtnClicked': 'targetProgrammed',
                            'onTimeout': 'waitForDeviceToBePluggedIn',
                            'backplane_disconnect': 'disconnected',
                            'backplane_disconnected': 'disconnected'
                        }
                    },

                    {
                        'name': 'downloadProgram',
                        'caption': 'Downloading program...',
                        'statusString': 'Downloading program...',
                        'waitForUser': false,
                        'skip': false,
                        'events': {
                            'gotoNextState': 'targetProgrammed',
                            'targetProgrammed': 'targetProgrammed',
                            'onProgramDownloadBtnClicked': 'downloadProgram',
                            'onSkipProgramDownloadBtnClicked': 'ready',
                            'onProgramDownloadSuccess': 'ready',
                            'onDownloadProgramError': 'waitForDeviceToBePluggedIn',
                            'onDebugServerError':'waitForDeviceToBePluggedIn',
                            'onProgramDownloadFailed': 'waitForDeviceToBePluggedIn',
                            'backplane_disconnect': 'disconnected',
                            'backplane_disconnected': 'disconnected'
                        }
                    },
                    {
                        'name': 'targetProgrammed',
                        'statusString': "target programmed",
                        'caption': 'Disconnect',
                        'waitForUser': false,
                        'skip': false,
                        'events': {
                            'gotoNextState': 'disconnect',
                            'onDownloadProgramError': 'waitForDeviceToBePluggedIn',
                            'onDebugServerError':'waitForDeviceToBePluggedIn',
                            'onProgramDownloadFailed': 'waitForDeviceToBePluggedIn',
                            'onProgramDownloadBtnClicked': 'downloadProgram',
                            'onProgramDownloadSuccess': 'ready',
                            'backplane_disconnect': 'disconnected',
                            'backplane_disconnected': 'disconnected'
                        }
                    },
                    {
                        'name': 'ready',
                        'statusString': "",
                        'caption': 'ready',
                        'waitForUser': false,
                        'skip': false,
                        'events': {
                            'gotoNextState': 'disconnect',
                            'onDownloadProgramError': 'waitForDeviceToBePluggedIn',
                            'onDebugServerError':'waitForDeviceToBePluggedIn',
                            'onProgramDownloadFailed': 'waitForDeviceToBePluggedIn',
                            'onProgramDownloadSuccess': 'ready',
                            'onProgramDownloadBtnClicked': 'downloadProgram',
                            'backplane_disconnect': 'disconnected',
                            'backplane_disconnected': 'disconnected'
                        }
                    },
                    {
                        'name': 'failed',
                        'statusString': "Failed to program device.",
                        'caption': 'Failed to program device.',
                        'waitForUser': false,
                        'skip': false,
                        'events': {
                            'gotoNextState': 'disconnect',
                            'onDownloadProgramError': 'failed',
                            'onDebugServerError':'waitForDeviceToBePluggedIn',
                            'onProgramDownloadFailed': 'failed',
                            'onProgramDownloadSuccess': 'ready',
                            'backplane_disconnect': 'disconnected',
                            'backplane_disconnected': 'disconnected'
                        }
                    },
                    {
                        'name': 'disconnect',
                        'statusString': '',
                        'caption': 'Disconnect',
                        'waitForUser': true,
                        'skip': false,
                        'events': {
                            'gotoNextState': 'disconnected',
                            'backplane_disconnect': 'disconnected',
                            'backplane_disconnected': 'disconnected'
                        }
                    }

                ],
                /** @private */
                userActions: ['onTargetReady','onUserSaysDevicePluggedIn', 'onDownloadProgramBtnClicked', 'onSkipDownloadBtnClicked'],
                /** @private */
                stateIndexes: {},
                /** @private */
                prevState: undefined,

                /**
                 * Fired when the currentState changes and the current state's waitForUser property is true.
                 *
                 * @event currentStateUpdated
                 */
                /**
                 * Fired when the status caption changes.
                 *
                 * @event statusMsgUpdated
                 */
                /**
                 * Fired when the client needs to show a 'unplug device and plug it back in' message.
                 *
                 * @event onReplugNeeded
                 */
                /**
                 * Fired when the visibility of one of the buttons in the application that is associated
                 * with ti-service-programloader needs to be changed
                 *
                 * @event programDownloadUIVisibilityChanged
                 */
                /**
                 * Fired when the program has been successully downloaded into flash memory
                 * and is ready for use
                 *
                 * @event programDownloadComplete
                 */
                /**
                 * Fired when the dialog cancel button is clicked
                 *
                 *
                 * @event cancelBtnClicked
                 */
                /**
                 *  Fired when the autoDownloadEnable flag has been changed.  detail = {value: newValue }
                 *
                 *  @event autoDownloadEnabledChanged
                 */
                /**
                 * Fired when the isProgramDownloadBtnVisible flag has been changed.
                 *
                 * @event programDownloadBtnVisibleChanged
                 */

                _deviceName: '',
                hostAttributes: {
                },

                properties: {
                    /** @private */
                    backplane: {
                        notify: true,
                        type: String,
                        value: undefined,
                        observer: "backplaneChanged"
                    },
                    /**
                     * An object that represents the device that is being interacted with.
                     * The object must have the following fields:
                     *  <p> {<br/>
                         *   boardName:     'MSP-EXP430G2 v1.5',<br/>
                         *   deviceName:      'MSP430G2553',<br/>
                         *   fileName:      'ReadTempAndSendToSerialPort.cpp.hex',<br/>
                         *   ccxmlString:   'the target ccxml file serialized as a string'<br/>
                         *   ccxmlFileName: 'name to use for the ccxml file to be used by TICloudAgent'
                         *   runTargetToReadMemory: 'true if a monitor on the target is used to read target memory'
                         *
                         *   }<br/>
                     *   <p>Additional fields can be added for other device-specific information.  e.g.
                     *   {
                         *   startBtnName:  'Name of button to press to start target running: e.g. P1.3',<br/>
                         *   boardImage:    'Name of image file of target board to display e.g. launchpad-mspexp430g2-02.jpg',<br/>
                         *   startBtnImage  'Name of image file showing location of start button e.g. startbutton-mspexp430g2-02.jpg'<br/>
                         *   }<br/>
                     * <p>
                     *
                     * @attribute selectedDevice
                     * @type object
                     * @default undefined
                     */
                    selectedDevice: {
                        notify: true,
                        type: Object,
                        value: undefined,
                        observer: "selectedDeviceChanged"
                    },

                    /** 
                     * The name of the target device for serial communications with the target.  This is only needed to auto program the
                     * the target device with an image.
                     *
                     * @attribute deviceName
                     * @type String
                     */
                    deviceName: {
                        type: String,
                        value: undefined
                    },

                    /** 
                     * The name of the connection for programming the target.
                     *
                     * @attribute connectionId
                     * @type String
                     */
                    connectionId: {
                        type: String,
                        value: undefined
                    },
                    /** 
                     * In a multi-core device, the name of the specific core for loading the program.  The default is to load the program
                     * on the first programmable core.
                     */
                    coreName: {
                        type: String,
                        value: undefined,
                        notify: false
                    },
                    /**
                     * A name-value JSON object device specific options to apply to the CloudAgent before flashing the device. This is an advanced
                     * feature use to override the default device programming options. When this property is set, it will replace the program_options.json
                     * file in the target folder.
                     *
                     * @attribute settings
                     * @type object
                     * @default undefined
                     */
                     programOptions: {
                        type: Object,
                        value: undefined
                    },
                    /**
                     * The name of the program to load onto the target device.  See 'targetFolder' and 'targetProgramBlob'
                     * @attribute targetProgram
                     * @type string
                     */
                    targetProgram: {
                        type: String,
                        value: undefined
                    },
                    /**
                     * If set, this property specifies the content to be programmed into the target, overriding
                     * the targetProgram and targetFolder property values.  This is only intended for rare situations
                     * where the user needs to dynamically modify the content to be programmed using Javascript.  In
                     * all other situations it is preferable to upload the file to be programmed into the application's
                     * target folder and to specify which file to program using the targetProgram and targetFolder
                     * properties
                     * @attribute targetProgramBlob
                     * @type object
                     * @default undefined
                     */
                    targetProgramBlob: {
                        type: Object,
                        value: undefined
                    },
                    /**
                     * The name of the program image to use to verify the program loaded into the target device.
                     * If specified, this will be used to determine whether or not the targetProgram is to be programmed
                     * into the device or not.  Stored in the same targetFolder as the targetProgram (See 'targetFolder')
                     * @attribute targetProgramVerifyImage
                     * @type string
                     */
                    targetProgramVerifyImage: {
                        type: String,
                        value: undefined
                    },
                    /**
                     * The relative or absolute path to the folder where the target program is located.
                     * this attribute is optional, and if omitted, the default folder is 'target/'.
                     * @attribute targetProgram
                     * @type string
                     */
                    targetFolder: {
                        type: String,
                        value: undefined
                    },
                    /**
                     * when true, indicates the program is to be loaded into volatile (static RAM) memory
                     *
                     * @attribute sram
                     * @type boolean
                     */
                    sram: {
                        type: Boolean,
                        value: false
                    },
                    /**
                     * The current state of this object's internal state machine.
                     *
                     * @attribute currentState
                     * @type string
                     * @default 'disconnected'
                     */
                    currentState: {
                        notify: true,
                        type: String,
                        value: undefined,
                        observer: "_currentStateChanged"
                    },
                    _currentStateName: "",
                    // see https://groups.google.com/forum/#!msg/polymer-dev/IX_gvSQT78Y/UtxDo-M2H6MJ
                    // and http://stackoverflow.com/questions/23861029/how-does-data-binding-in-polymer-work

                    /**
                     * a string representing the current status of the interactions with the target device.
                     *
                     * @attribute status
                     * @type string
                     * @default 'Disconnected.'
                     */
                    status: {
                        notify: true,
                        type: String,
                        value: ""
                    },
                    /**
                     * isProgramDownloadDisabled is set to true by the application in situations where
                     * there is no program to download to the target (e.g. the program has already
                     * been downloaded to the target)
                     *
                     * @attribute isProgramDownloadDisabled
                     * @type boolean
                     * @default false
                     */
                    isProgramDownloadDisabled: {
                        notify: true,
                        type: Boolean,
                        value: false
                    },
                    /**
                     * isAutoDownloadEnabled is set by the application in situations where the program
                     * should always be automatically downloaded to the target after connection to the
                     * target has been established.  If false, the application should provide a button
                     * that the user can click on to initiate the program download, and call the
                     * initiateProgramDownload function in response.
                     *
                     * @attribute isAutoDownloadEnabled
                     * @type boolean
                     * @default false
                     */
                    isAutoDownloadEnabled: {
                        notify: true,
                        type: Boolean,
                        value: false,
                        observer: "_isAutoDownloadEnabledChanged"
                    },
                    /**
                     * isProgramDownloadBtnVisible indicates whether a button labeled 'Download program' with an on-click handler
                     * of onDownloadProgramBtnClicked should be displayed or not.
                     *
                     * @attribute isProgramDownloadBtnVisible
                     * @type boolean
                     * @default false
                     */
                    isProgramDownloadBtnVisible: {
                        notify: true,
                        type: Boolean,
                        value: false,
                        observer:"_isProgramDownloadBtnVisibleChanged"
                    },
                    /**
                     * wasProgramDownloadSuccessful indicates whether the program has been successfully downloaded into the
                     * target's flash memory or not.  Read this value in response to the programDownloadComplete event
                     * to determine whether the target is ready to use or not.
                     *
                     * @attribute wasProgramDownloadSuccessful
                     * @type boolean
                     * @default false
                     */
                    wasProgramDownloadSuccessful: {
                        notify: true,
                        type: Boolean,
                        value: false
                    },
                    /** Set to true when object ready has occurred
                     * @attribute initialized
                     * @type boolean
                     * @default false
                     */
                    initialized: {
                        notify: true,
                        type: Boolean,
                        value: false,
                        observer: "_initializedChanged"
                    },
                    /**
                     * ID of the transport associated with this program loader
                     *
                     * @attribute transportId
                     * @type String
                     * @defualt null
                     */
                    transportId: {
                        notify: true,
                        type: String,
                        value: undefined
                    },
                    /** @private */
                    coreProgramLoaderId: {
                        notify: false,
                        type: String,
                        value: undefined
                    },
                    /**
                     * callback function that is called when a status message has been received from ti-service-programloader.
                     * Callback function takes two parameters: a string containing the status message that was received,
                     * and a string that is set to either 'error' or 'info' to indicate the type of status message
                     *
                     * @attribute statusUpdateCallback
                     * @type function
                     * @default null
                     */
                    statusUpdateCallback: {
                        notify: false,
                        type: Function,
                        value: null
                    },
                    /**
                     * the ccxml file for the target
                     * @attribute defaultCcxml
                     * @type string
                     * @default null
                     */
                    defaultCcxml: {
                        notify: false,
                        type: String,
                        value: null,
                        observer:"_defaultCcxmlChanged"
                    },
                    /**
                     * For binary files, this specifies the first program address that the binary file is to be loaded into.
                     * (Note: this property is not used for .out files or .cpp.hex files)
                     *
                     * @attribute loadAddress
                     * @type Number
                     * @default 0x000000
                     */
                    loadAddress: {
                        notify: false,
                        type: Number,
                        value: 0
                    },
                    /**
                     * Set to true for apps where the ti-service-programloader is used in a
                     * stand-alone device programming configuration
                     *
                     * @attribute standAlone
                     * @type Boolean
                     * @default false
                     */
                    standAlone: {
                        notify: true,
                        type: Boolean,
                        value: false
                    }
                },
                /** @private */
                _successMsg: "Flash Successful!",
                getSuccessMsg: function() {
                    return this._successMsg;
                },
                _updateStatusMessage: function(msg,msgType){
                    if (this.statusUpdateCallback){
                        this.statusUpdateCallback(msg,msgType);
                    }
                },
                _isAutoDownloadEnabledChanged: function(newValue,oldValue){
                    this.fire('autoDownloadEnabledChanged',{value: newValue })
                },
                _isProgramDownloadBtnVisibleChanged: function(newValue,oldValue){
                    this.fire('programDownloadBtnVisibleChanged',{value: newValue});
                },
                /**
                 * Programs the flash memory of the connected device.  Automatically disconnects if already connected and then
                 * connects to the target device in order to allow multiple calls to the API to be made.
                 * If no parameters are passed in, the deviceName, fileName and fileFolderPath property values will be used.
                 *
                 * @param stayConnectedWhenDone: if true, the target is not disconnected upon completion of programming the device
                 * @param attrOverridesObj: (optional) - object that contains override values for the following properties:
                 *  * deviceName: (optional) the name of the device (see ti-core-backplane demo for a list of supported devices)
                 *  * targetProgram: (optional) the name of the .cpp.hex or .out file to program the device with
                 *  * targetFolder: (optional) the relative path to the .cpp.hex or .out file
                 *  * connectionIdArg: (optional) the connection ID to use for the Cloud Agent
                 * @return a promise that resolves when the programming has completed and is rejected if any error occurs.
                 */
                programDevice: function(stayConnectedWhenDone, attrOverridesObj) {
                    var deviceName = this.deviceName;
                    if (attrOverridesObj && attrOverridesObj.deviceName){
                        deviceName = attrOverridesObj.deviceName;
                    }
                    var fileName = this.targetProgram;
                    if (attrOverridesObj && attrOverridesObj.targetProgram){
                        fileName = attrOverridesObj.targetProgram;
                    }
                    var fileFolderPath = this.targetFolder;
                    if (attrOverridesObj && attrOverridesObj.targetFolder){
                        fileFolderPath = attrOverridesObj.targetFolder;
                    }
                    var connId = this.connectionId;
                    if (attrOverridesObj && attrOverridesObj.connectionId) {
                        connId = attrOverridesObj.connectionId;
                    }
                    var programOptions = this.programOptions;
                    if (attrOverridesObj && attrOverridesObj.programOptions) {
                        programOptions = attrOverridesObj.programOptions;
                    }
                    myDevice = {
                        deviceName: deviceName,
                        fileName: fileName,
                        fileFolderName: fileFolderPath,
                        connectionID: connId,
                        programOptions: programOptions

                    };
                    this._updateStatusMessage("Initializing connection info...","info");

                    return gc.services['ti-core-backplane'].getCcxmlFilePlusObjects(deviceName, connId).then(function(result){
                        if (!connId || connId.length === 0) {
                            myDevice.connectionID = result.connectionObj.xmlFile;
                        }
                        this.connectionId = myDevice.connectionID;
                        this.selectedDevice = myDevice;
                        this.deviceName = myDevice.deviceName;
                        this.targetFolder = myDevice.fileFolderName;
                        this.targetProgram = myDevice.fileName;
                        this.programOptions = myDevice.programOptions;
                        return this.disconnect();
                    }.bind(this)).then(function(){
                        return this.connect(myDevice);
                    }.bind(this)).then(function(){
                        this._updateStatusMessage("Connected.","info");
                        return this.doProgramTargetDevice(this._updateStatusMessage.bind(this));
                    }.bind(this)).fail(function(errMsg){
                        this._updateStatusMessage(errMsg,"error");
                        throw new Error(errMsg);
                    }.bind(this)).finally(function(){
                        // do not update status message because it will cause the previous success / error message to be lost
                        if (!stayConnectedWhenDone){
                            return this.disconnect();
                        }
                        return true;
                    }.bind(this));
                },


                /**
                 * Helper API that connects to TI Cloud Agent
                 *
                 * @param selectedDeviceObj - an object with the following properties: deviceName, fileName, fileFolderName, connectionID.
                 * @return a promise that resolves when the device is connected
                 */
                connect: function(selectedDeviceObj) {
                    this._updateStatusMessage("Connecting...","info");
                    return gc.services['ti-core-backplane'].connect(selectedDeviceObj);
                },

                /**
                 * Helper API that disconnects from TI Cloud Agent and puts the ti-service-programloader into a state where it
                 * is ready to program the device in the future
                 *
                 * @return a promise that resolves when the device is disconnected
                 */
                disconnect: function () {
                    var result = Q.defer();
                    gc.services['ti-core-backplane'].disconnect();
                    this.async(function(){
                        this.updateStateMachine('showDownloadProgramBtn');
                        this.async(function(){
                            result.resolve();
                        }.bind(this),1);
                    }.bind(this),1);
                    return result.promise;
                },
                _backplaneCurrentStateChangedHdlr: function(e) {
                    if (this.backplane.currentState) {
                        gc.console.debug(ServiceName, 'backplaneCurrentState changed to ' + this.backplane.currentState.name);
                        this.updateStateMachine('backplane_' + this.backplane.currentState.name);
                    }
                },
                /** @private */
                backplaneCurrentStateChangedHdlr: undefined,

                _backplaneConnectionStatusChangedHdlr: function(e) {
                    gc.console.debug(ServiceName, 'backplaneConnectionState changed .isConnectedToCloudAgent=' + e.target.isConnectedToCloudAgent);

                },
                /** @private */
                backplaneConnectionStatusChangedHdlr: undefined,

                _backplaneBtnVisibilityChangedHdlr: function(e) {
                    if (e.target.isDisconnectBtnVisible) {
                        this.isReplugNoticeVisible = false;
                    }
                },
                _initiateReconnect: function(){
                    gc.services = gc.services || {};
                    var targetAccess = gc.services['ti-service-targetaccess'];
                    if (targetAccess){
                        targetAccess.forceInitiateReconnect();
                    } else {
                        gc.connectionManager.disconnect().finally(function () {
                            gc.console.log(ServiceName, "reconnecting after programming device...");
                            this.async(function () {
                                this._programLoader.isAutoDownloadEnabled = false;
                                gc.connectionManager.connect().then(function () {
                                    gc.console.log(ServiceName, "Reconnected.");
                                }).fail(function (err) {
                                    gc.console.log(ServiceName, "Reconnection failed: err = " + err);
                                });
                            }, 800);
                        }.bind(this));
                    }
                },
                /**
                 * called by the Program Loader dialog when the user clicks OK.  Responsible for disconnecting from the
                 * target or, if there is a ti-service-targetaccess, reconnecting to the target
                 */
                initiateReconnect: undefined,
                _defaultCcxmlChanged: function(newValue,oldValue){
                    if (!newValue) return;
                    if (newValue.indexOf('%SERIAL') > 0){
                        gc.console.error(ServiceName, "defaultCcxml file has unresolved serial port! "+newValue);
                    } else {
                        gc.console.debug(ServiceName, "defaultCcxml updated - ok.")
                    }
                },
                /** @private */
                backplaneBtnVisibilityChangedHdlr: undefined,

                /** @private */
                backplaneChanged: function(newBackplane,oldBackplane) {
                    if ((oldBackplane !== undefined) &&(oldBackplane !== null)){
                        oldBackplane.removeEventListener("currentStateUpdated", this.backplaneCurrentStateChangedHdlr);
                        oldBackplane.removeEventListener("connectionStatusChanged", this.backplaneConnectionStatusChangedHdlr);
                        oldBackplane.removeEventListener("btnVisibilityChanged", this.backplaneBtnVisibilityChangedHdlr);
                    }
                    if (this.backplane !== undefined) {
                        this.backplane.addEventListener("currentStateUpdated", this.backplaneCurrentStateChangedHdlr);
                        this.backplane.addEventListener("connectionStatusChanged", this.backplaneConnectionStatusChangedHdlr);
                        this.backplane.addEventListener("btnVisibilityChanged", this.backplaneBtnVisibilityChangedHdlr);
                        // Have to wait until after the backplane has started TI Cloud Agent before calling getDs!
                        if (this.backplane.currentState !== undefined) {
                            gc.console.debug(ServiceName, 'backplane event handlers initialized. backplane.currentState.name=' + this.backplane.currentState.name);
                        }
                        if (this.backplane.selectedDevice === undefined) {
                            this.backplane.selectedDevice = this.selectedDevice;
                        } else {
                            this.selectedDevice = this.backplane.selectedDevice;
                        }
                        this.backplaneCurrentStateChangedHdlr();
                        this.fire('backplaneChanged');
                    }
                },

                /** @private */
                selectedDeviceChanged: function() {
                    // for backwards compatibility with older application code:
                    if ((this.selectedDevice.deviceName === undefined) && (this.selectedDevice.chipName !== undefined)){
                        this.selectedDevice.deviceName = this.selectedDevice.chipName;
                    }
                    this._deviceName = this.selectedDevice.deviceName;
                    if (this.selectedDevice.boardName === undefined) {
                        this.selectedDevice.boardName = this.selectedDevice.deviceName;
                    }
                    this.boardName = this.selectedDevice.boardName;

                    this.fileName = this.selectedDevice.fileName;
                    this.fileFolderName = this.selectedDevice.fileFolderName;
                },

                _setStatus: function(strStatus) {
                    this.status = strStatus;
                    if (this.statusUpdateCallback){
                        this.statusUpdateCallback(this.status,this.status.toUpperCase().indexOf('ERROR') >= 0 ? 'error' : 'info');
                    }
                    if (strStatus.length > 0) {
                        this.fire('statusMsgUpdated',{statusMsg: this.status});
                    }
                },
                /** @private */
                setStatus: undefined,

                _cancelButtonClicked: function() {
                    this.fire('cancelBtnClicked');
                },
                /** @private */
                cancelButtonClicked: undefined,
                _getCurrentStateName: function(){
                    return this.currentState.name;
                },
                getCurrentStateName: undefined,
                //provided for testing purposes
                /* returns true if state changed, false otherwise */
                _updateStateMachine: function(strEventName) {
                    if ((!this.$) || (!this.initialized)) return;
                    var result = false;
                    var origStateName = this.currentState.name;
                    var newStateName = this.currentState.events[strEventName];
                    if (newStateName) {
                        gc.console.debug(ServiceName, 'updateStateMachine event = ' + strEventName);
                        if (newStateName !== origStateName) {
                            this.prevState = this.currentState;
                            var newIndex = this.stateIndexes[newStateName];
                            this.currentState = this.states[newIndex];
                            gc.console.debug(ServiceName, 'state change from ' + origStateName + ' to ' + newStateName);
                        }
                        result = true;
                    } else {
                        gc.console.debug(ServiceName, 'OUT OF SEQUENCE updateStateMachine event: ' + strEventName);
                        gc.console.debug(ServiceName, this.currentState.events.length + ' valid event names for state=' + this.currentState.name + ':');
                        for (var i = 0; i < this.currentState.events.length; i++) {
                            gc.console.debug(ServiceName, 'event[' + i + ']=' + this.currentState.events[i].name);
                        }
                    }

                    return (result);
                },
                /** @private */
                updateStateMachine: undefined,

                _currentStateChanged: function() {

                    if (!this.initialized) return;
                    var _self = this;
                    gc.console.debug(ServiceName, 'onCurrentStateChanged: currentState.name=' + this.currentState.name);
                    this.prevState = this.currentState;
                    this._currentStateName = this.currentState.name;
                    switch (this.currentState.name) {
                        case 'disconnected':
                            this.isProgramDownloadBtnVisible = false;

                            this.fire('programDownloadUIVisibilityChanged');
                            break;
                        case 'backplaneReady':
                            var dialog = this._getDialog();
                            if (dialog && dialog.close && !this.isAutoDownloadEnabled) {
                                dialog.close(); // close dialog when reconnecting to target.
                            }
                            this.updateStateMachine('showDownloadProgramBtn');
                            break;
                        case 'showDownloadProgramBtn':
                            if ((this.backplane) && (this.backplane.agent)) {
                                var dialog = this._getDialog();
                                if (!this.isProgramDownloadDisabled || (!gc.connectionManager && dialog.isDialogOpen)) {
                                    if (this.isAutoDownloadEnabled) {
                                        this.isAutoDownloadEnabled = false;
                                        this.updateStateMachine('downloadProgram');
                                    } else {
                                        // wait for the onDownloadBtnClicked event to flash the device
                                        this.isProgramDownloadBtnVisible = true;
                                        this.fire('programDownloadUIVisibilityChanged');
                                    }
                                } else {
                                    this.updateStateMachine('onSkipProgramDownloadBtnClicked');
                                }
                            }
                            break;
                        case 'downloadProgram':
                            this.isProgramDownloadBtnVisible = false;
                            this.wasProgramDownloadSuccessful = false;
                            // do not clear isAutoDownloadEnabled flag until after successfully programming the device.
                            this.setStatus('Downloading program...');
                            this.fire('programDownloadUIVisibilityChanged');
                            this.ds = this.backplane.ds;
                            gc.console.debug(ServiceName, 'ds =' + this.ds);
                            var _self = this;
                            this.configureDebugServerIfNeeded(true).then(function() {
                                if (_self.backplane.isDebugServerConfigured) {
                                    _self.core = _self.backplane.core;
                                    return _self.flashDevice();
                                } else {
                                    throw("backplane.isDebugServerConfigured = false");
                                }
                            }).fail(function(error){
                                var errMsg = _self._getErrMsg(error);
                                if (errMsg.indexOf("error=") < 0) {
                                    errMsg = "Error configuring Debug Server: error="+errMsg;
                                }
                                gc.console.debug(ServiceName, ''+errMsg);
                                _self.setStatus(errMsg);
                                _self.updateStateMachine('onProgramDownloadFailed');
                            });
                            break;
                        case 'targetProgrammed':
                            this.isProgramDownloadBtnVisible = false;
                            this.fire('programDownloadUIVisibilityChanged');
                            break;
                        case 'ready':
                            if (this.isProgramDownloadBtnVisible) {
                                this.isProgramDownloadBtnVisible = false;
                                this.fire('programDownloadUIVisibilityChanged');
                            }
                            this._successMsg = "Flash Successful!";
                            if (this.sram) {
                                this._successMsg = "Program Load into SRAM Successful!"
                            }
                            this.setStatus(this._successMsg);
                            if (this.myTimeout !== null){
                                window.clearTimeout(this.myTimeout);
                                this.myTimeout = null;
                            }
                            this.wasProgramDownloadSuccessful = true;
                            this.isAutoDownloadEnabled = false;
                            gc.console.debug(ServiceName, 'firing programDownloadComplete event...');
                            this.fire('programDownloadComplete');
                            this.fire('programmingStatusChanged');
                            break;
                        case 'failed':
                        case 'waitForDeviceToBePluggedIn':
                            this.isProgramDownloadBtnVisible = false;
                            this.isReplugNoticeVisible = true;
                            this.fire('programDownloadUIVisibilityChanged');
                            this.ds_loader = undefined;
                            //fire an event to notify the client that they need to show a 'unplug device and plug it back in' message.
                            this.fire('replugNoticeVisibilityChanged');
                            this.fire('programmingStatusChanged');
//                        this.backplane.updateStateMachine('onDisconnectBtnClicked');
                            break;
                        case 'disconnect':
                            this.ds_loader = undefined;
                            this.isProgramDownloadBtnVisible = false;
                            this.fire('programDownloadUIVisibilityChanged');
                            this.updateStateMachine('disconnectComplete');
                            break;

                    }
                    if (this.currentState.waitForUser) {
                        this.fire('currentStateUpdated');
                    }
                },
                /** @private */
                currentStateChanged: undefined,

                /** @private */
                setUserAction: function(e) {
                    gc.console.debug(ServiceName, 'setUserAction: ' + e);
                    if (this.currentState.events[e]) {
                        this.currentState = this.states[this.stateIndexes[this.currentState.events[e]]];
                        gc.console.debug(ServiceName, 'updated currentState to ' + this.currentState.name);
                    }
                },
                /**
                 * downloads the file specified by the parameter object to the cloud agent's file store
                 * @param target - object : name property specifies file name, path property specifies path to the file
                 */
                downloadFile: function(target) {
                    var _self = this;
                    var path = target.getAttribute("path");
                    var name = target.getAttribute("name");
                    if (ticloudagent_isSafari()) {
                        var a = document.createElement("a");
                        a.download = name;
                        a.href = path;
                        a.click();
                    }
                    else {
                        var req = new XMLHttpRequest();
                        req.open('GET', path, true);
                        req.responseType = "blob";
                        req.onreadystatechange = function() {
                            if (req.readyState == 4) {
                                require("./FileSaver");
                                saveAs(req.response, name);
                            }
                        };
                        req.send(null);
                    }
                },

                /** @private */
                waitForSocketConnection: function(socket, callback) {
                    setTimeout(
                        function() {
                            if (socket.readyState === 1) {
                                if (callback !== undefined) {
                                    callback();
                                }
                                return;
                            } else {
                                // keep waiting if socket is connecting
                                if (socket.readyState == 0) {
                                    waitForSocketConnection(socket, callback);
                                } else {
                                    //TODO: handle case where socket is closing (2) or closed(3)
                                    gc.console.error(ServiceName, "ERROR: webSocket readyState =" + socket.readyState + ', (2=closing, 3=closed)');
                                }
                            }
                        }, 5);
                },
                /** @private */
                MSG_TYPES: {
                    WAITING_FOR_BINARY_DATA: "DS_WAITING_FOR_BINARY_DATA",
                    ERROR: "DS_ERROR",
                    SUCCESS: "DS_SUCCESS",
                    OUTPUT_TEXT: "DS_OUTPUT_TEXT"
                },
                /** @private */
                createBaseMessageHandler: function(output, callback, input) {

                    var MSG_SUCCESS = 'flash successful';
                    var baseMessageHandler = {};
                    baseMessageHandler[this.MSG_TYPES.WAITING_FOR_BINARY_DATA] = function(message) {
                    };

                    baseMessageHandler[this.MSG_TYPES.ERROR] = function(message) {
                        /*if ((output !== undefined) && (output !== null)) {
                         output.text(message.data);
                         }
                         */
                        gc.console.error(ServiceName, 'ccs_debug baseMessageHandler: error = ' + message.data);
                        //TODO define proper errors like DS.ERROR
                        callback({name: "error", message: message.data}, message.data);
                    };

                    baseMessageHandler[this.MSG_TYPES.SUCCESS] = function(message) {
                        if (((typeof message.data) === 'string') && (output !== undefined) && (output !== null)) {
                            //output.text(message.data);
                            gc.console.debug(ServiceName, 'ccs_debug baseMessageHandler: success = ' + message.data);
                            if (message.data.toLowerCase().indexOf(MSG_SUCCESS) >= 0) {
                                gc.console.debug(ServiceName, 'ccs_debug baseMessageHandler: setting foundFlashMsg = true');
                                _self.foundFlashMsg = true;
                                window.clearTimeout(this.myTimeout);
                                _self.timeoutSet = false;
                            }
                        } else {
                            gc.console.debug(ServiceName, 'ccs_debug baseMessageHandler: success! about to call callback (e.g. programLoadComplete)');
                        }

                        callback(null, input ? input : message.data);
                    };

                    baseMessageHandler[this.MSG_TYPES.OUTPUT_TEXT] = function(message) {
                        if ((message === null) || (message === undefined) || (message.data === undefined) || (message.data === null)) {
                            gc.console.warning(ServiceName, 'ccs_debug baseMessageHandler: output_text - null message!');

                        } else {
                            gc.console.debug(ServiceName, 'ccs_debug baseMessageHandler: output_text = ' + message.data);
                            // possible messages: Flashing Device... Flash Successful!
                            if (message.data.toLowerCase().indexOf(MSG_SUCCESS) >= 0) {
                                gc.console.debug(ServiceName, 'ccs_debug baseMessageHandler: setting foundFlashMsg = true');
                                _self.foundFlashMsg = true;
                                window.clearTimeout();
                                _self.timeoutSet = false;
                            }
                        }
                        if ((output !== undefined) && (output !== null)) {
                            output.text(message.data);
                        }
                    };

                    baseMessageHandler.handle = function(msgEvt) {
                        var message = JSON.parse(msgEvt.data);
                        var handler = this[message.msgType];
                        handler ? handler(message) : gc.console.warning(ServiceName, "Unhandled Message Type : " + message.msgType);
                    };

                    return baseMessageHandler;
                },
                /** @private */
                consoleOutput: function() {
                    text = function(message) {
                        gc.console.debug(ServiceName, message);
                    }
                },

                /** @private */
                socketCache: [],
                /** @private */
                socketUrl: function(port) {
                    if (backplane.isSecureWebPage) {
                        return "wss://localhost:" + port + "/socket/";
                    } else {
                        return "ws://localhost:" + port + "/socket/";
                    }
                },
                /** @private */
                stringEndsWith: function(str, suffix) {
                    return str.indexOf(suffix, str.length - suffix.length) !== -1;
                },
                /** @private */
                stringStartsWith: function(str, prefix){
                    return str.indexOf(prefix) === 0;
                },
                /**
                 * returns a valid path to a file located in the app's target folder.  If no override parameters
                 * are passed in it looks up the path and file name from the selectedDevice.
                 * If there is no selectedDevice, it uses the target folder and the file name spedcified in the project.json
                 * target_out_filename property.
                 *
                 * @param targetFolderPath (optional) - overrides the path to the target folder
                 * @param targetProgramName (optional) - specifies the file name to use
                 * @return promise that resolves to the path to the target program
                 */
                getPathToTargetProgram: function(targetFolderPath, targetProgramName, isVerifyImage) {
                    var _self = this;
                    var result = null;
                    return Q.promise(function(resolve) {
                        if ((targetProgramName) && (targetFolderPath)) {
                            result = targetFolderPath;
                            if (!_self.stringEndsWith(targetFolderPath,'/')) {
                                result += '/';
                            }
                            result += targetProgramName;
                            gc.console.debug(ServiceName, "getPathToTargetProgram = "+result);
                            return resolve(result);
                        } else {
                            if (isVerifyImage) return resolve(null);  // do not automatically return the name of the .out file as the verification image
                            if (_self.selectedDevice !== undefined) {
                                if (!_self.stringEndsWith(_self.selectedDevice.fileFolderName, '/')) {
                                    result = _self.selectedDevice.fileFolderName + '/' + _self.selectedDevice.fileName;
                                } else {
                                    result = _self.selectedDevice.fileFolderName + _self.selectedDevice.fileName;
                                }
                                gc.console.debug(ServiceName, "getPathToTargetProgram = " + result);
                                return resolve(result);
                            } else {
                                return gc.fileCache.readJsonFile('project.json').then(function (manifest) {
                                    result = path.join(manifest.target_out_foldername, manifest.target_out_filename);
                                    gc.console.debug(ServiceName, "getPathToTargetProgram = " + result);
                                    return (resolve(result));

                                }).fail(function (error) {
                                    gc.console.debug(ServiceName, 'getPathToTargetProgram: Could not read project.json file.  error = ' + error);
                                    return resolve(null);
                                });
                            }
                        }

                    });
                },
                setSelectedDeviceIfNeeded: function(forceConfigure){
                    var _self = this;
                    if (!forceConfigure && _self.backplane.selectedDevice && _self.backplane.selectedDevice.deviceName) return Q.resolve();
                    return Q().then(function() {
                        if (_self.deviceName && _self.connectionId) {
                            if (forceConfigure) {
                                _self.defaultCcxml = null;
                            }
                            return _self.backplane.setSelectedDevice(_self.deviceName, _self.connectionId, _self.defaultCcxml).then(function(){
                                _self.backplane.selectedDevice.fileName = _self.targetProgram;
                                _self.backplane.selectedDevice.fileFolderName = _self.targetFolder;
                                return Q.resolve();
                            });
                        } else {
                            if (!_self.deviceName) {
                                throw("Please specify deviceName");
                            }
                            throw("Please specify connectionId");
                        }
                    });
                },
                configureDebugServerIfNeeded: function(forceConfigure){
                    var _self = this;
                    if (!forceConfigure && _self.backplane.isDebugServerConfigured) return Q.resolve();
                    return this.setSelectedDeviceIfNeeded(forceConfigure).then(function() {
                        return Q.promise(function(resolve) {
                            var ccxmlStr = _self.defaultCcxml;
                            if (!ccxmlStr){
                                ccxmlStr = _self.backplane.selectedDeviceCcxmlString;
                            }
                            _self.backplane.configureDebugServer(_self.backplane.selectedDevice.deviceName+'.ccxml',ccxmlStr,false, false, resolve, true, _self.transportId, false, _self.coreName);

                        }).then(function(error) {
                            if (!error) {
                                return (_self.programOptions ? Q(_self.programOptions) : gc.fileCache.readJsonFile((_self.targetFolder || 'target') + '/program_options.json')).then(function(programOptions) {
                                    const coreSettings = _self.backplane.core.settings;
                                    const settingQ = [];
                                    for (const option of Object.entries(programOptions)) {
                                        settingQ.push(coreSettings.set(option.join('=')));
                                    }
                                    return Q.all(settingQ).fail(function(err) {
                                        gc.console.error(ServiceName, `Error while applying settings.json, ${_self._getErrMsg(err)}`);
                                        return err;
                                    }).then(function() {
                                        /* convert array of results to single return return */
                                    });

                                }).fail(function(err) {
                                    /* ignore no settings.json file */

                                });

                            } else {
                                return error;
                            }

                        }).then(function(error) {
                            // configure the target ccxml file (if required).  If this has already been done, it will call
                            // the callback function with error = null and isDebugServerConfigured = true.
                            if ((!_self.backplane.isDebugServerConfigured) ||
                                ((error !== undefined) && (error !== null))) {
                                // don't throw unless error is defined
                                if (error) {
                                    var msg = _self._getErrMsg(error);
                                    throw("Error configuring Debug Server: error=" + msg);
                                }
                            } else {
                                if (_self.backplane.isDebugServerConfigured) {
                                    _self.core = _self.backplane.core;
                                } else {
                                    throw("backplane.isDebugServerConfigured = false")
                                }
                            }
                            return Q.resolve();
                        });
                    });

                },
                /**
                 * Handles programming the device, optionally verifying the program that is already on the device and only
                 * programming the device if the current program on the device is not valid.
                 * Relies on the following properties being set:
                 * - targetFolder
                 * - targetProgram
                 * - targetProgramVerifyImage (optional)
                 *
                 * @return promise that resolves when programming is complete
                 */
                flashDevice: function() {
                    this.isFlashComplete = false;
                    var _self = this;
                    var pathToTargetProgram = null;
                    var pathToTargetProgramVerifyImage = null;
                    this.setStatus('Downloading program...');
                    return Q.all([
                        _self.getPathToTargetProgram((_self.targetFolder || 'target'), _self.targetProgram,false).then(function(filePath) {
                            return filePath;
                        }).fail(function(err){
                            return null;
                        }),
                        _self.getPathToTargetProgram((_self.targetFolder || 'target'), _self.targetProgramVerifyImage,true).then(function(filePath) {
                            return filePath;
                        }).fail(function(err){
                            return null;
                        }),
                        _self.configureDebugServerIfNeeded()
                    ]).then(function(results){
                        if (!_self.targetProgramBlob && !results[0]) {
                            throw ("No program file specified.");
                        }
                        pathToTargetProgram = results[0];
                        pathToTargetProgramVerifyImage = results[1];

                        const coreName = _self.coreName ? ` core=${_self.coreName}` : '';
                        _self.setStatus('Downloading program into ' + _self.deviceName + coreName + ' ...');
                        _self.myTimeout = window.setTimeout(function () {
                            gc.console.warning(ServiceName, "Timeout waiting for programming to complete.");
                            _self.onProgrammingStatusUpdate(
                                {message: 'Timeout waiting for mspdebug.'}, "Timeout");
                            _self.updateStateMachine('onDownloadProgramError');
                        }, _self.MS_WAIT_FOR_FLASH_PROGRAMMING_COMPLETE);
                        return _self.downloadProgram(_self.core, false, pathToTargetProgram,pathToTargetProgramVerifyImage);
                    }).then(function () {
                        _self.updateStateMachine('onProgramDownloadSuccess');
                        if (_self.myTimeout !== undefined) {
                            window.clearTimeout(_self.myTimeout);
                        }
                        _self.myTimeout = undefined;
                    }).fail(function (error) {
                        var msg = "";
                        var boardName = _self._getBoardName();
                        if (typeof error === 'string'){
                            msg = error;
                        } else {
                            if (error.message){
                                msg = error.message;
                            }
                        }
                        if (msg.length > 0) {
                            gc.console.error(ServiceName, 'Error downloading program: error.message=' + msg);
                            msg = "Error downloading program: " + msg;
                            if (msg.indexOf("404") === -1) {
                                msg += "  Please unplug your " + boardName + ", then plug it back in and try again."
                            }
                        } else {
                            msg = "Error downloading program: Please unplug your " + boardName + ", then plug it back in and try again";
                        }
                        _self.setStatus(msg);
                        if (_self.myTimeout !== undefined) {
                            window.clearTimeout(_self.myTimeout);
                        }
                        _self.myTimeout = undefined;
                        _self.updateStateMachine('onDownloadProgramError');
                    });
                },
                _getBoardName: function(){
                    var result = this.boardName;
                    if (!this.boardName || this.boardName === "") {
                        result = "target device";
                        if (this.selectedDevice) {
                            if (this.selectedDevice.boardName) {
                                result = _self.selectedDevice.boardName;
                            } else if (_self.selectedDevice.deviceName) {
                                result = _self.selectedDevice.deviceName;
                            }
                        }
                    }
                    return result;
                },
                _getErrMsg: function(errStringOrObject){
                    var errMsg = 'unknown.';
                    if (errStringOrObject !== undefined){
                        errMsg = errStringOrObject;
                        if (Array.isArray(errStringOrObject)) {
                            errMsg = errStringOrObject[0];
                        } else {
                            if (errStringOrObject.message !== undefined) {
                                errMsg = errStringOrObject.message;
                            } else if (errStringOrObject.msg !== undefined) {
                                errMsg = errStringOrObject.msg;
                            }
                        }
                     }
                    return errMsg;
                },
                /** @private
                 *
                 * downloads program or loads symbols into specified core
                 *
                 * @param coreObj - the dslite core object to load the program into
                 * @param symbolsOnly - if true, only symbols are loaded into the device.  The device is not flashed.
                 * @param programPathUrl - path to the file to use for symbols or to program the device with
                 * @parem programVerifyPathUrl - (optional) path to the file to use to verify the device image with
                 * @return promise that resolves when programming is complete
                 */
                downloadProgram: function(coreObj, symbolsOnly, programPathURL, programVerifyPathURL){
                    var _self = this;
                    var verificationSetting = '';
                    var verificationFailed = false;
                    if (!this.backplane){
                        throw "ti-service-programloader.downloadProgram: backplane not defined"
                    }
                    if (!this.backplane.selectedDevice) {
                        throw "ti-service-programloader.downloadProgram: backplane.selectedDevice not defined"
                    }
                    if (!this.selectedDevice){
                        this.selectedDevice = this.backplane.selectedDevice;
                    }
                    if (!this.selectedDevice) {
                        throw "ti-service-programloader.downloadProgram: selectedDevice not defined"
                    }
                    if (!this.selectedDevice.deviceName) {
                        throw "ti-service-programloader.downloadProgram: selectedDevice.deviceName not defined"
                    }
                    var programPath = '';
                    var programDataFileName =  _self.selectedDevice.deviceName + '.data';
                    var programVerifyPath = null;
                    var programVerifyFileName = _self.selectedDevice.deviceName + '_verify.data';
                    var verifyWithProgramDataFile = (programPathURL === programVerifyPathURL);
                    var isBinFile = false;
                    if (programPathURL) {
                        isBinFile = programPathURL.indexOf('.bin') > 0;
                    }
                    return Q.promise(function(resolve,reject) {
                        try {
                            if ((!_self.targetProgramBlob) && !(programPathURL && programPathURL.length > 0)) {
                                return reject('No Target Program Specified');
                            }
                            if (!coreObj) {
                                return reject('No Target Device core specified');
                            }
                            var dataPromise = Q.Promise.resolve(_self.targetProgramBlob);
                            if (!_self.targetProgramBlob) {
                                dataPromise = (window.parent.gc.fileCache || window.gc.fileCache).readBinaryFile(programPathURL);
                            }
                            dataPromise.then(function (data) {
                                //var blob = new Blob([data], {type: 'application/octet-binary'});
                                //return TICloudAgent.Util.encodeAsBase64(blob);
                                return TICloudAgent.Util.encodeAsBase64(data);
                            }).then(function (data) {
                                return _self.backplane.file.write(programDataFileName, data);
                            }).then(function (obj) {
                                programPath = obj.path.replace(/\\/g, "/");

                                // turn off auto run label, so our program will be just running after
                                if (symbolsOnly) {
                                    if (isBinFile){
                                        throw (".bin file");
                                    } else {
                                        throw ("symbols only");
                                    }
                                } else {
                                    return coreObj.expressions.evaluate("DEBUG_SetStringProperty( \"AutoRunToLabelName\", \"\" )");
                                }
                            }).then(function (result) {
                                if (!programVerifyPathURL) {
                                    throw "skip verification";
                                }
                                // Note: VerifyAfterProgramLoad is a bad name for this property - it controls how verification is done when symbols.verifyProgram is called.
                                return coreObj.settings.get("VerifyAfterProgramLoad")
                            }).then(function (value) {
                                verificationSetting = value;
                                return coreObj.settings.set({VerifyAfterProgramLoad: "Full verification"})
                            }).then(function(){
                                if (verifyWithProgramDataFile) {
                                    return null;
                                }
                                return (window.parent.gc.fileCache || window.gc.fileCache).readBinaryFile(programVerifyPathURL);
                            }).then(function (data) {
                                if (verifyWithProgramDataFile) {
                                    return null;
                                }
                                return TICloudAgent.Util.encodeAsBase64(data);
                            }).then(function(data) {
                                if (verifyWithProgramDataFile) {
                                    return null;
                                }
                                return _self.backplane.file.write(programVerifyFileName, data);
                            }).then(function(obj) {
                                if (verifyWithProgramDataFile) {
                                    programVerifyPath = programPath;
                                } else {
                                    programVerifyPath = obj.path.replace(/\\/g, "/");
                                }

                            }).then(function () {
                                // now do verify
                                gc.console.debug(ServiceName, 'loadProgram: about to call verify programVerifyPath=' + programVerifyPath);
                                return coreObj.symbols.verifyProgram(programVerifyPath);
                            }).then(function () {
                                gc.console.debug(ServiceName, "verification passed. ");
                                //return coreObj.expressions.evaluate('GEL_Reset()');
                            }).catch(function (err) {  // catch here, because we only want to catch failures for verify and not earlier failures
                                // verification failed for some reason, so load the program
                                var errMsg = _self._getErrMsg(err);
                                if (err === ".bin file"){
                                    // do nothing - this is thrown in the 'symbols only' step, but there are no symbols for a .bin file.
                                    gc.console.debug(ServiceName, 'loadProgram: skipping loading symbols for .bin file.  ... programPath=' + programPath);
                                    return;
                                }
                                if (err === "symbols only"){
                                    gc.console.debug(ServiceName, 'loadProgram: about to loadSymbols.  programPath= ' + programPath);
                                    return coreObj.symbols.loadSymbols(programPath);
                                } else {
                                    if (err !== "skip verification") {
                                        gc.console.debug(ServiceName, 'loadProgram: verification failed.  err = ' + errMsg);
                                        verificationFailed = true;
                                    }
                                    if (!isBinFile) {
                                        gc.console.debug(ServiceName, 'loadProgram: about to loadProgram.  programPath= ' + programPath);
                                        return coreObj.symbols.loadProgram(programPath).fail(function (err) {
                                            var errMsg = _self._getErrMsg(err);
                                            gc.console.error(ServiceName, "Failed to load " + programPath + ": err=" + errMsg);
                                        });
                                    } else {
                                        gc.console.debug(ServiceName, 'loadProgram: about to load binary Program.  programPath= ' + programPath+", loadAddress="+gc.utils.getHexString(_self.loadAddress));
                                        return coreObj.symbols.loadProgramOnly({filename: programPath,loadAddress:_self.loadAddress}).fail(function (err) {
                                            var errMsg = _self._getErrMsg(err);
                                            gc.console.error(ServiceName, "Failed to load " + programPath + ": err=" + errMsg);
                                        });
                                    }
                                }
                            }).finally(function () {
                                if ((!symbolsOnly) && (programVerifyPathURL)) {
                                    if (!verificationFailed) {
                                        gc.console.debug(ServiceName, 'loadProgram: verification OK, skipping loadProgram.');
                                        _self.setStatus("Program verification passed, skipping re-programming device.");
                                    }
                                    coreObj.settings.set({VerifyAfterProgramLoad: verificationSetting});
                                }
                            }).then(resolve,reject);

                        } catch(e) {
                            reject(e);
                        }
                    });
                },

                /** @private */
                onProgrammingStatusUpdate: function(error, text) {
                    //bc: HACK: not sure why timeout messages are coming in after flash successful
                    gc.console.debug(ServiceName, 'in callback from backplane.flash');
                    if (!this.isFlashComplete) {
                        if (text) {
                            gc.console.debug(ServiceName, 'ds_loader.localServer.flash text = ' + text);
                            var lcText = text.toLowerCase();
                            if (lcText.indexOf('erase successful') >= 0) {
                                this.isEraseComplete = true;
                                this.setStatus('Erase complete...');
                                if (this.myTimeout !== null) {
                                    window.clearTimeout(this.myTimeout);
                                    this.myTimeout = null;
                                }
                                this.myTimeout = window.setTimeout(function(){this.onProgrammingStatusUpdate({message: 'Timeout waiting for mspdebug.'},"Timeout");},this.MS_WAIT_FOR_FLASH_PROGRAMMING_COMPLETE);
                            } else {
                                if (lcText.indexOf('success') >= 0) {
                                    this.isFlashComplete = true;
                                }
                            }
                            this.setStatus(this.downloadingStatusMsgPrefix + ': ' + text);

                        }
                        if (error) {
                            if ((error.message !== undefined) && (error.message !== null)) {
                                gc.console.error(ServiceName, 'Error downloading program: error.message' + error.message);
                            } else {
                                gc.console.error(ServiceName, 'Error downloading program.  error.message == null or undefined');
                            }
                            this.setStatus("Error downloading program: Please unplug your " + this._getBoardName() + ', plug it back in, click Disconnect and try again.' +
                                '  Please also close any other windows that are running this demo and close any applications such as mspdebug or Energia that are connected to your Launchpad.');
                            this.updateStateMachine('onProgramDownloadFailed');

                        } else {
                            if ((this.isFlashComplete) && (!this.hasOpenSerialPortBeenCalled)) {
                                gc.console.debug(ServiceName, 'in callback from flash - no error.  Download complete.  About to open serial port');
                                this.setStatus("Download complete.");
                                if (this.myTimeout !== null) {
                                    window.clearTimeout(this.myTimeout);
                                    this.myTimeout = null;
                                }
                                this.hasOpenSerialPortBeenCalled = true;
                                this.updateStateMachine('onProgramDownloadSuccess');
                            }
                        }
                    } else {
                        // Put breakpoint here:
                        gc.console.debug(ServiceName, 'debug this: isFlashComplete=' + this.isFlashComplete + ', hasOpenSerialPortBeenCalled=' + this.hasOpenSerialPortBeenCalled + ', text=' + text + ',error=' + error);
                    }
                },
                _initializedChanged: function(newValue, oldValue){
                    gc.console.debug(ServiceName, "initialized set to "+this.initialized);
                },
                created: function() {
                    this.setStatus = this._setStatus.bind(this);
                    this.initiateReconnect = this._initiateReconnect.bind(this);
                    this.updateStateMachine = this._updateStateMachine.bind(this);
                    this.cancelButtonClicked = this._cancelButtonClicked.bind(this);
                    this.currentStateChanged = this._currentStateChanged.bind(this);
                    this.backplaneCurrentStateChangedHdlr = this._backplaneCurrentStateChangedHdlr.bind(this);
                    this.backplaneConnectionStatusChangedHdlr = this._backplaneConnectionStatusChangedHdlr.bind(this);
                    this.backplaneBtnVisibilityChangedHdlr = this._backplaneBtnVisibilityChangedHdlr.bind(this);
                    this.getCurrentStateName = this._getCurrentStateName.bind(this);
                },
                ready: function() {
                    this.enteredView();
                    // this.addEventListener("valueChanged",dialValueChangedHandler,false);
                },

                // see https://groups.google.com/forum/#!searchin/polymer-dev/binding/polymer-dev/wzfxU9vVAg0/1sFyrmnxy5EJ for info on why initialization is not
                // considered complete until either enteredView or created is called
                /** @private */
                enteredView: function() {
                    this.stateIndexes = {};
                    for (var i = 0; i < this.states.length; i++) {
                        this.stateIndexes[this.states[i].name] = i;
                    }
                    this.currentState = this.states[0];
                    this.prevState = this.currentState;

                    this.currentState = this.states[0];
                },
                /** @private */
                dialog: undefined,
                _getDialog: function(){
                    var result = this.dialog;
                    if (!result) {
                        result = document.querySelector('ti-service-programloader-dialog');
                        if (!result) {
                            result = document.createElement('ti-service-programloader-dialog');
                            result.id = "programLoaderDialog";
                            document.body.appendChild(result);
                        }
                        this.dialog = result;
                    }
                    return result;
                },
                attached: function() {
                    gc.services = gc.services || {};
                    programLoaderServiceInstances.push(this);
                    gc.services[ServiceName] = programLoaderServiceInstances[0];

                    // have to programmatically add the dialog, which listens for events to display itself automatically.
                    this.dialog = this._getDialog();
                    this.initialized = true;

                    var _self = this;
                    var onBackplaneRegistered = function() {
                        _self.backplane = gc.services['ti-core-backplane'];
                        document.removeEventListener('ti-core-backplane-ready', onBackplaneRegistered);
                    };

                    if ((gc.services !== undefined) && (gc.services['ti-core-backplane'])) {
                        onBackplaneRegistered();
                    } else {
                        document.addEventListener('ti-core-backplane-ready', onBackplaneRegistered);
                    }
                    document.dispatchEvent(new CustomEvent("ti-service-programloader-ready", { "detail": "Programloader is Ready" }));
                },
                detached: function() {
                    for(var i = programLoaderServiceInstances.length; i--> 0; ) {
                        if(programLoaderServiceInstances[i] === this) {
                            programLoaderServiceInstances.splice(i, 1);
                        }
                    }
                    gc.services[ServiceName] = programLoaderServiceInstances[0];
                    this.backplane = undefined;
                },
                /**
                 * @return true if the device supports programming (i.e. is not using a UART connection) and the backplane is available
                 */
                doesSelectedDeviceSupportDownload: function() {
                    var result = ((this.backplane) && (this.backplane.selectedDevice) &&
                        (this.backplane.selectedDevice.connectionId !== 'UART connection'));
                    return this.backplane;
                },
                /**
                 * @return true if the device can be programmed at the time the function is called.
                 */
                canProgramTargetDevice: function()
                {
                    return this.isProgramDownloadBtnVisible;
                },
                /**
                 * Promise chain that handles programming and calls back into the progressCallback when there is a status update
                 *
                 * @param progressCallback - callback function to be called when there is a status update.  takes 2 parameters: status, msgType (e.g. 'error' or 'info')
                 */
                doProgramTargetDevice: function(progressCallback)
                {
                    return Q.promise(function(resolve, reject)
                    {
                        var downloadStatusListener = function()
                        {
                            progressCallback(this.status, this.status.toUpperCase().indexOf('ERROR') >= 0 ? 'error' : 'info');
                        }.bind(this);

                        var downloadFinishedListener = function(event)
                        {
                            var stopListening = false;
                            if (this.currentState.name === "downloadProgram") return;  // ignore the initial messages
                            if (this.currentState.name === "disconnected"){
                                reject("Target disconnected.");
                                stopListening = true;
                            }
                            if (this.wasProgramDownloadSuccessful)
                            {
                                resolve();
                                stopListening = true;
                            }
                            else {
                                gc.console.debug(ServiceName, "doProgramTargetDevice: received event.type = "+event.type);
                                switch(event.type){
                                    case "replugNoticeVisibilityChanged":
                                        if (this.isReplugNoticeVisible) {
                                            reject("Please plug in your target device.");
                                            stopListening = true;
                                        }
                                        break;
                                }
                            }

                            if (stopListening) {
                                this.removeEventListener('programDownloadUIVisibilityChanged', downloadFinishedListener);
                                this.removeEventListener('replugNoticeVisibilityChanged', downloadFinishedListener);
                                this.removeEventListener('programDownloadComplete', downloadFinishedListener);
                                this.removeEventListener('statusMsgUpdated', downloadStatusListener);
                            }
                        }.bind(this);

                        if (this.currentState.name !== "showDownloadProgramBtn"  &&  this.currentState.name !== "downloadProgram" && this.currentState.name !== "targetProgrammed")
                        {
                            reject('Program flash is not available for this device at this time.');
                        }
                        else
                        {
                            if (progressCallback)
                            {
                                this.addEventListener('statusMsgUpdated', downloadStatusListener);
                            }
                            if (this.currentState.name !== "downloadProgram") {
                                this.updateStateMachine('onProgramDownloadBtnClicked');
                            }
                            this.addEventListener('programDownloadComplete', downloadFinishedListener);
                            this.addEventListener('replugNoticeVisibilityChanged', downloadFinishedListener);
                            this.addEventListener('programDownloadUIVisibilityChanged', downloadFinishedListener);
                        }
                    }.bind(this));
                }
            })
        }());
    </script>

</dom-module>
